### go 언어 특징
- 정적 타입, 강타입
- 컴파일 언어
- 가비지 컬렉션
- 병행성 (Concurrency)
- 멀티코어 환경 지원
- 모듈화 및 패키지 시스템
- 빠른 컴파일
- C 언어 문법을 기반, 간결

### 정적 타입, 강타입
- 컴파일 시에 자료형이 결정되면 정적 타입
- 암묵적 형변환을 수행하면 약 타입, 수행 안하면 강타입, 고언어는 강타입

### 컴파일 언어
- 소스 코드를 컴파일 하여 기계어로 된 실행 파일을 만들어냄
- 바로 CPU에서 실행되므로 속도가 빠르고 간결
- Java나 C#은 바이트 코드로 된 IL(Intermediate Language)를 생성, 이를 가상머신에서 실행
- go는 가상머신 없이 곧바로 실행 파일을 CPU에서 실행

### 가비지 컬렉션
- go 언어는 가비지 컬렉션을 제공하여 메모리 관리에 신경을 써주지 않아도 됨
- 가비지 컬렉터가 실행 파일 안에 내장
- C,C++의 실행 파일이 주는 간결함과 가상 머신의 가비지 컬렉션 기능을 모두 갖추고 있다.

### 병행성
- 언어 차원에서 병행성을 지원
- 병행성(Concurrency): 동시 처리의 논리적인 개념. 단일 코어 멀티 쓰레드가 여기에 해당함
- 병렬성(Parallelism): 물리적 차원의 병렬 처리
- 쓰레드는 운영체제 커널이 제공하는 리소스, 부담이 큼
- 고루틴 생성 후 적정량의 쓰레드를 생성해서 고루틴을 처리의
- 최대 프로세서(코어) 개수 설정에 따라 멀티 코어 지원 가능

### 모듈화 및 패키지
- 언어 자체에서 모듈화 제공, 인터넷의 소스 코드를 곧바로 가져올 수 있음
- go get, go install 등의 명령어

### 컴파일 속도
- 헤더 파일 없음, 소스 코드를 패키지화 하여 변경된 부분만 컴파일 하여 컴파일 속도가 빠름
- 간결한 문법으로 컴파일에 유리

### 활용 범위
- 웹 브라우저, 서버, 데이터 베이스 등 규모가 크고 복잡한 애플리케이션 개발에 적합
- 메모리 관리보다 로직에 집중하는 것이 중요
- 생산성이 뛰어남
- 메모리 관리를 철저히 해야하는 시스템 라이브러리 개발에 적합치 않음
- 메모리 및 장치에 직접 접근해야하는 운영체제와 장치 드라이버도 개발이 어려움
- 메모리 관리가 다소 느슨해도 되고 규모가 크고 복잡하며 유지보수가 빈번한 곳에서 사용 가능
- 인터넷 프로그래밍에 유용

### 오버플로우와 언더플로우
- go에서는 오버플로우와 언더플로우 발생 시 컴파일 에러를 내버림

### 상수
- const 키워드 사용
- 선언과 동시에 반드시 초기화, 이후 변경 불가

### 패키지
- 패키지 import 시에 import f fmt 처럼 별칭을 붙일 수 있음
- 패키지 명 앞에 _ 를 붙여주면 import 하고 사용하지 않더라도 컴파일 에러가 발생하지 않음

### if문
- if 문 안에서 함수 실행이 가능, 이를 활용해서 에러 검사하면 유용
```
if b, err := ioutil.ReadFile("./hello.txt"); err == nil {
  fmt.Println(err);
}
```

### for, continue
- go에서는 반복문이 for 밖에 없음
- for {}로 무한루프 생성 가능
- for문 시작 전에 라벨을 붙이고, 중첩 for문 내에서 한번에 break 가능
```
Loop:
  for i:=0; i<3; i++ {
    for j:=0; j<3; j++ {
      if j==2 {
        break Loop
      }
    }
  }
```
- 라벨과 for문 사이에 추가적인 코드가 들어가면 안됨
- continue도 마찬가지로 라벨과 함께 사용이 가능함

### case
- break 사용해서 특정 분기문의 실행을 중지 시킬 수 있음
```
s := "Hello"
i := 2
switch {
  case 1:
    fmt.Println(1)
  case 2:
    if s=="Hello" {
      fmt.Println("Hello 2")
      break
    }
    fmt.Println(2)
}
```
