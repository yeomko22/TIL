Q: 프로세스란?
- 프로그램이 메모리 위에 올라가 CPU의 할당을 받을 수 있는 상태가 된 것.

Q: 프로세스의 상태 변화에 대해 설명하시오
- ready queue에서 CPU의 할당을 대기하는 ready 상태, CPU 할당을 받고 연산을 수행하는 running 상태, io 작업을 요청하고 완료될 때까지 기다리는 wait 상태, 모든 작업을 마치고 종료된 terminated 상태가 있다.

Q: 프로세스 테이블이란?
- 프로세스의 상태를 추적하기 위해서 운영체제가 관리하는 테이블 형식의 자료구조

Q: PCB를 설명하라
- 운영체제가 프로세스를 관리하기 위한 데이터 구조로 커널 영역에서 만들어진다. 즉, 프로세스는 프로그램과 PCB로 이루어진다.

Q: 컨텍스트 스위치를 설명하라
- CPU가 여러개의 프로세스의 작업을 수행하기 위해서 현재 처리하던 작업을 멈추고 다른 프로세스의 작업을 처리하는 과정
- 현재 처리 중인 작업 중단 시 상태를 해당 프로세스의 PCB에 저장한다.

Q: 스택 오버 플로우는 어떤 상황에서 발생하는가?
- 스택은 함수 호출 시에 할당되는 로컬 변수나 되돌아가는 주소 값이 저장되는 영역이다. 만일 특정 함수를 무한히 호출하게 되면 stackoverflow가 발생하게 된다.

Q: 쓰레드와 프로세스의 차이를 설명하라
- 쓰레드는 프로세스 내의 하나의 실행 흐름을 나타낸다. 하나의 프로세스는 다수의 쓰레드를 포함할 수 있다. 하나의 프로세스 내의 쓰레드들은 각자 고유한 스택 영역과 프로그램 카운터를 가지며, 나머지 쓰레드들과 코드, 데이터, 힙 영역을 공유하게 된다.

Q: 리눅스에서 쓰레드는 어떻게 구현되는가?
- 리눅스에서는 별도로 쓰레드를 구현하지 않고 경량화 된 프로세스 형태로 쓰레드를 구현한다.

Q: 쓰레드 스위치가 프로세스 스위치에 비해서 가벼운 이유를 설명하라
- 프로세스 스위치 시에는 새로운 프로세스의 PCB를 메모리 상에 올려놓아야 한다. 그러나 쓰레드 스위치 시에는 PCB 교체가 필요 없다. 따라서 쓰레드 스위치 시에는 캐시 메모리를 그대로 활용이 가능하고 프로세스 스위치 시에는 캐시 메모리를 비워주고 새로운 데이터를 채워 넣어주어야 하는 오버헤드가 발생한다.

Q: deadlock이란?
- 서로 다른 프로세스가 서로에게 필요한 자원을 점유하고 있으면서 서로에게 자원을 요청하여 영원히 대기 중인 상태를 말한다.

Q: deadlock의 발생 조건은?
- mutual exclusion: 동시에 여러 프로세스가 동일한 자원을 점유하지 못함
- hold and wait: 프로세스가 적어도 하나 이상의 자원을 점유한 상태에서 다른 프로세스에게 자원을 요청
- no preemption: 이미 점유된 자원을 다른 프로세스가 뺐어갈 수 없음.
- circular wait: 자원을 요청하는 관계가 원형을 이룸

Q: deadlock을 해결할 수 있는 방법들은?
- 예방: 4가지 조건 중 하나라도 미리 막는 것
- 회피: 교착 상태 가능성이 있을 경우 자원 할당을 중단하고 지켜봄
- 검출 및 회복: 자원 할당 그래프를 모니터링하며 교착 상태를 확인, 교착 발생시 회복
- 세 가지 방법 중 예방과 회피는 실효성이 낮고 검출 및 회복을 사용한다.

Q: virtual memory란?
- 메모리 관리 기법 중 하나로 실제 메모리 공간보다 큰 메모리 영역을 제공한다. 이는 RAM 공간 뿐만 아니라 디스크 공간도 함께 활용하여 구현된다. 프로세스 동작 시에 RAM에 올라와 있지 않은 데이터에 접근시 페이지 폴트를 발생시켜 물리 메모리에서 필요한 데이터를 RAM으로 올린다. 
- 각각의 프로세스는 자신만의 주소 공간을 가지며 페이지 테이블을 통해서 이를 관리한다.

Q: 페이지 폴트를 설명하라
- 프로세스의 논리 메모리 공간에는 올라와 있지만 물리 메모리 공간에 올라와 있지 않은 데이터나 코드에 접근할 경우 발생하는 현상이다. 페이지 폴트가 일어나면 디스크 공간에서 필요한 데이터를 찾아내어 물리 메모리에 올린다. 만일 물리 메모리에 여유 공간이 없다면 victim을 선정하여 디스크 공간으로 내린 뒤, 올린다. 그 다음 페이지 테이블의 상태 값을 업데이트 해준다.

Q: 디맨드 페이징이란?
- 프로세스의 모든 페이지를 메모리에 올려놓지 않고, 필요한 시점에 디스크 공간에서 메모리로 올리는 기법

Q: Thrashing이란?
- 쓰레싱이란 실제 연산을 수행하는 것보다 페이지 폴트가 더 많이 발생하여 프로세스를 처리하는 속도가 느려지는 현상을 가리킨다. 흔히 동시에 처리하는 프로세스의 수가 많아질 수록 CPU 사용률이 늘어나지만 일정 수준을 넘어서면 페이지 폴트를 처리하느라 오히려 CPU 사용률이 떨어지게 되며 이를 쓰레싱이라 부른다.

Q: belady 모순이란?
- 페이지 교체 알고리즘에 따라서 물리 메모리 공간을 늘려주어도 오히려 페이지 폴트가 증가하는 현상을 가리킴. FIFO에서 발생

Q: mutex와 semaphore의 차이
- semaphore는 wait와 signal 두 atomic operation을 사용한다. counting semaphore와 binary semaphore 두 종류가 있다. 
- mutex는 오로지 mutex를 획득한 쓰레드에서만 할당 해지를 할 수 있다. binary semaphore는 어떤 쓰레드에서도 시그널을 보낼 수 있다. mutex는 하나의 프로세스 내에서 멀티 쓰레드 동기화 시에 사용하고 semaphore는 멀티 프로세스 동기화 시에 사용한다.

Q: fragmentation을 설명하시오
- fragmentation은 기본적으로 메모리 공간이 낭비되는 현상을 가리킴
- internal fragmentation이란 메모리 공간을 블럭으로 나누어 할당할 때, 실제 데이터가 차지하는 공간을 제외한 나머지 공간이 비게 되는 현상
- external fragmentation이란 메모리 공간 상에 실제적인 빈공간은 충분하지만, 프로세스들이 차지하고 있는 간격 때문에 새로운 프로세스를 할당할 수 없는 현상

Q: 동기, 비동기, 블럭킹, 논블록킹에 대해 설명하라
- 동기는 함수를 호출 시에 해당 함수의 종료 여부를 호출한 쪽에서 확인하는 방식을 말한다. 비동기 방식은 호출한 쪽에서는 신경쓰지 않고 함수가 완료된 이후 콜백 함수를 통해서 전달받게 된다.
- 블럭킹 논블록킹은 실행 흐름에 관련된 개념으로 블록킹은 함수 호출시 원래 실행흐름을 멈추며 논블로킹은 멈추지 않는다. 흔히 동기 블록킹과 비동기 논블록킹을 조합해 사용한다.

Q: race condition이란?
- 동시에 여러 쓰레드가 동일한 자원에 접근하는 상황을 말한다.

 Q: critiacl section이란?
 - 공유자원이 동시에 여러 쓰레드에 의해 접근되어 질 수 있는 코드 영역을 말하며 동기화 처리에 의해 보호해야한다.

 Q: critical section 해결 조건을 설명하라
 - mutual exclusion: critical section으로 진입하는 프로세스는 하나여야 한다.
 - bounded waiting: 어떤 프로세스도 critical section으로 진입하기 위해 무한히 대기해서는 안된다.
 - progress flexibility: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.

Q: MMU(Memory Manage Unit) 역할
- fetch, placement, replacement를 담당
- 프로세스와 데이터를 메모리로 가져오고(fetch), 메모리의 어느 위치에 할당할 지를 결정하고(placement), 꽉찼다면 기존에 올라와 있는 데이터 중 일부를 디스크 공간으로 옮김(replacement)

